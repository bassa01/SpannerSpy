package main

import (
	"testing"

	"github.com/cloudspannerecosystem/memefish"
)

func TestSchemaBuilderParsesInterleavedSchema(t *testing.T) {
	ddl := `
        CREATE TABLE Parents (
            ParentId INT64 NOT NULL,
            Name STRING(64),
            Balance NUMERIC,
            Profile JSON,
            CreatedAt TIMESTAMP NOT NULL
        ) PRIMARY KEY (ParentId);

        CREATE TABLE Children (
            ParentId INT64 NOT NULL,
            ChildId INT64 NOT NULL,
            Tags ARRAY<STRING(16)>,
            Metadata JSON,
            Picture BYTES(MAX),
            Active BOOL,
            BirthDate DATE,
            Ratio FLOAT64,
            Score INT64
        ) PRIMARY KEY (ParentId, ChildId),
          INTERLEAVE IN PARENT Parents;

        ALTER TABLE Children
          ADD CONSTRAINT fk_children_parent
          FOREIGN KEY (ParentId)
          REFERENCES Parents (ParentId);
    `

	schema := parseSchema(t, ddl)
	if len(schema.Tables) != 2 {
		t.Fatalf("expected 2 tables, got %d", len(schema.Tables))
	}

	child := mustTable(t, schema, "Children")
	if child.InterleavedIn != "Parents" {
		t.Fatalf("expected Children to be interleaved in Parents, got %q", child.InterleavedIn)
	}

	if got := len(child.PrimaryKey); got != 2 {
		t.Fatalf("expected composite primary key, got %d columns", got)
	}
	if child.PrimaryKey[0] != "ParentId" || child.PrimaryKey[1] != "ChildId" {
		t.Fatalf("unexpected primary key order: %v", child.PrimaryKey)
	}

	tags := mustColumn(t, child, "Tags")
	if tags.Type != "STRING(16)" || !tags.IsArray {
		t.Fatalf("unexpected array column representation: %+v", tags)
	}

	picture := mustColumn(t, child, "Picture")
	if picture.Type != "BYTES(MAX)" || picture.IsArray {
		t.Fatalf("unexpected BYTES column representation: %+v", picture)
	}

	if !columnIsNotNull(mustColumn(t, child, "ParentId")) {
		t.Fatal("ParentId should be marked as NOT NULL")
	}
	if !columnIsNotNull(mustColumn(t, child, "ChildId")) {
		t.Fatal("ChildId should be marked as NOT NULL")
	}

	if schema.ForeignKeys == nil || len(schema.ForeignKeys) != 1 {
		t.Fatalf("expected one foreign key, got %v", schema.ForeignKeys)
	}
	fk := schema.ForeignKeys[0]
	if fk.Name != "fk_children_parent" {
		t.Fatalf("unexpected foreign key name: %q", fk.Name)
	}
	if fk.ReferencedTable != "Parents" || fk.ReferencingTable != "Children" {
		t.Fatalf("unexpected foreign key tables: %+v", fk)
	}
}

func TestSchemaBuilderHandlesAlterTableMutations(t *testing.T) {
	ddl := `
        CREATE TABLE Projects (
            ProjectId INT64 NOT NULL,
            Name STRING(MAX)
        ) PRIMARY KEY (ProjectId);

        CREATE TABLE Tasks (
            TaskId INT64 NOT NULL,
            ProjectId INT64 NOT NULL,
            Deprecated STRING(10)
        ) PRIMARY KEY (TaskId);

        ALTER TABLE Tasks ADD COLUMN Description STRING(MAX) NOT NULL;
        ALTER TABLE Tasks ADD COLUMN Labels ARRAY<STRING(MAX)>;
        ALTER TABLE Tasks DROP COLUMN Deprecated;
        ALTER TABLE Tasks ADD CONSTRAINT fk_tasks_projects
            FOREIGN KEY (ProjectId) REFERENCES Projects (ProjectId);
        ALTER TABLE Tasks DROP CONSTRAINT fk_tasks_projects;
        ALTER TABLE Tasks ADD FOREIGN KEY (ProjectId) REFERENCES Projects (ProjectId);
        ALTER TABLE Tasks SET INTERLEAVE IN PARENT Projects;
    `

	schema := parseSchema(t, ddl)
	tasks := mustTable(t, schema, "Tasks")

	if tasks.InterleavedIn != "Projects" {
		t.Fatalf("Tasks should be interleaved in Projects, got %q", tasks.InterleavedIn)
	}

	if _, ok := columnByName(tasks, "Deprecated"); ok {
		t.Fatal("Deprecated column should have been dropped")
	}

	desc := mustColumn(t, tasks, "Description")
	if desc.Type != "STRING(MAX)" || !columnIsNotNull(desc) {
		t.Fatalf("Description should be a NOT NULL STRING(MAX): %+v", desc)
	}

	labels := mustColumn(t, tasks, "Labels")
	if !labels.IsArray || labels.Type != "STRING(MAX)" {
		t.Fatalf("Labels should be an ARRAY<STRING(MAX)>: %+v", labels)
	}

	if schema.ForeignKeys == nil || len(schema.ForeignKeys) != 1 {
		t.Fatalf("expected one foreign key, got %v", schema.ForeignKeys)
	}
	fk := schema.ForeignKeys[0]
	if fk.Name != "Tasks_ProjectId_fk" {
		t.Fatalf("expected autogenerated foreign key name, got %q", fk.Name)
	}
	if len(fk.ReferencingColumns) != 1 || fk.ReferencingColumns[0] != "ProjectId" {
		t.Fatalf("unexpected referencing columns: %+v", fk.ReferencingColumns)
	}
}

func TestSchemaBuilderDropColumnRemovesPrimaryKeyEntry(t *testing.T) {
	ddl := `
        CREATE TABLE AuditLog (
            TenantId INT64 NOT NULL,
            EventId INT64 NOT NULL,
            Payload STRING(MAX)
        ) PRIMARY KEY (TenantId, EventId);

        ALTER TABLE AuditLog DROP COLUMN TenantId;
    `

	schema := parseSchema(t, ddl)
	audit := mustTable(t, schema, "AuditLog")

	if len(audit.Columns) != 2 {
		t.Fatalf("expected two columns after drop, got %d", len(audit.Columns))
	}

	if _, ok := columnByName(audit, "TenantId"); ok {
		t.Fatal("TenantId column should have been removed")
	}

	if len(audit.PrimaryKey) != 1 || audit.PrimaryKey[0] != "EventId" {
		t.Fatalf("expected primary key to shrink to EventId, got %v", audit.PrimaryKey)
	}
}

func TestSchemaBuilderRowDeletionPolicies(t *testing.T) {
	ddl := `
        CREATE TABLE Sessions (
            SessionId INT64 NOT NULL,
            ExpiresAt TIMESTAMP NOT NULL
        ) PRIMARY KEY (SessionId),
          ROW DELETION POLICY (OLDER_THAN(ExpiresAt, INTERVAL 7 DAY));

        ALTER TABLE Sessions
          REPLACE ROW DELETION POLICY (OLDER_THAN(ExpiresAt, INTERVAL 14 DAY));

        ALTER TABLE Sessions
          DROP ROW DELETION POLICY;

        ALTER TABLE Sessions
          ADD ROW DELETION POLICY (OLDER_THAN(ExpiresAt, INTERVAL 21 DAY));
    `

	schema := parseSchema(t, ddl)
	sessions := mustTable(t, schema, "Sessions")
	if sessions.RowDeletionPolicy == nil {
		t.Fatal("expected Sessions to retain a row deletion policy")
	}

	if sessions.RowDeletionPolicy.ColumnName != "ExpiresAt" {
		t.Fatalf("unexpected row deletion column: %q", sessions.RowDeletionPolicy.ColumnName)
	}
	if sessions.RowDeletionPolicy.NumDays != "21" {
		t.Fatalf("row deletion interval should be 21 days, got %s", sessions.RowDeletionPolicy.NumDays)
	}
}

func TestSchemaBuilderIndexes(t *testing.T) {
	ddl := `
        CREATE TABLE Projects (
            ProjectId INT64 NOT NULL,
            OwnerId INT64 NOT NULL,
            Status STRING(32),
            UpdatedAt TIMESTAMP
        ) PRIMARY KEY (ProjectId);

        CREATE UNIQUE NULL_FILTERED INDEX idx_projects_owner_status
          ON Projects (OwnerId ASC, Status DESC)
          STORING (UpdatedAt),
          INTERLEAVE IN Projects;
    `

	schema := parseSchema(t, ddl)
	if len(schema.Indexes) != 1 {
		t.Fatalf("expected 1 index, got %d", len(schema.Indexes))
	}

	idx := schema.Indexes[0]
	if idx.Name != "idx_projects_owner_status" {
		t.Fatalf("unexpected index name: %q", idx.Name)
	}
	if idx.Table != "Projects" {
		t.Fatalf("unexpected indexed table: %q", idx.Table)
	}
	if !idx.IsUnique || !idx.IsNullFiltered {
		t.Fatalf("expected unique + null filtered flags, got %+v", idx)
	}
	if idx.InterleavedIn != "Projects" {
		t.Fatalf("expected index interleaved in Projects, got %q", idx.InterleavedIn)
	}
	if len(idx.Columns) != 2 {
		t.Fatalf("expected two index columns, got %d", len(idx.Columns))
	}
	if idx.Columns[0].Name != "OwnerId" || idx.Columns[0].Direction != "ASC" {
		t.Fatalf("unexpected first index column: %+v", idx.Columns[0])
	}
	if idx.Columns[1].Name != "Status" || idx.Columns[1].Direction != "DESC" {
		t.Fatalf("unexpected second index column: %+v", idx.Columns[1])
	}
	if len(idx.Storing) != 1 || idx.Storing[0] != "UpdatedAt" {
		t.Fatalf("unexpected storing columns: %v", idx.Storing)
	}
}

// parseSchema turns a DDL string into a Schema using memefish to mirror the CLI pipeline.
func parseSchema(t *testing.T, ddl string) *Schema {
	t.Helper()
	ddls, err := memefish.ParseDDLs("test.sql", ddl)
	if err != nil {
		t.Fatalf("failed to parse DDL: %v", err)
	}
	schema, err := buildSchema(ddls)
	if err != nil {
		t.Fatalf("failed to build schema: %v", err)
	}
	return schema
}

func mustTable(t *testing.T, schema *Schema, name string) *Table {
	t.Helper()
	for i := range schema.Tables {
		if schema.Tables[i].Name == name {
			return &schema.Tables[i]
		}
	}
	t.Fatalf("table %q not found", name)
	return nil
}

func columnByName(table *Table, name string) (Column, bool) {
	for _, column := range table.Columns {
		if column.Name == name {
			return column, true
		}
	}
	return Column{}, false
}

func mustColumn(t *testing.T, table *Table, name string) Column {
	t.Helper()
	column, ok := columnByName(table, name)
	if !ok {
		t.Fatalf("column %q not found in table %s", name, table.Name)
	}
	return column
}

func columnIsNotNull(column Column) bool {
	return column.IsNullable != nil && !*column.IsNullable
}
